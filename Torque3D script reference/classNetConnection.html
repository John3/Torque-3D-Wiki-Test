<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Torque 3D - Script Manual: NetConnection Class Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" href="https://github.com/LuisAntonRebollo/Torque-3D-Wiki-Test/wiki">Wiki</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER -->
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>NetConnection Class Reference<br/>
<small>
[<a class="el" href="group__Networking.html">Networking</a>]</small>
</h1><!-- doxytag: class="NetConnection" --><!-- doxytag: inherits="SimGroup" -->
<p>Provides the basis for implementing a multiplayer game protocol.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for NetConnection:</div>
<div class="dynsection">
<div class="center"><img src="classNetConnection__inherit__graph.png" border="0" usemap="#NetConnection_inherit__map" alt="Inheritance graph"/></div>
<map name="NetConnection_inherit__map" id="NetConnection_inherit__map">
<area shape="rect" href="classGameConnection.html" title="The game&#45;specific subclass of NetConnection." alt="" coords="5,304,125,331"/><area shape="rect" href="classSimGroup.html" title="A collection of SimObjects that are owned by the group." alt="" coords="25,155,105,181"/><area shape="rect" href="classSimSet.html" title="A collection of SimObjects." alt="" coords="33,80,97,107"/><area shape="rect" href="classSimObject.html" title="Base class for almost all objects involved in the simulation." alt="" coords="24,5,107,32"/><area shape="rect" href="classAIConnection.html" title="Special client connection driven by an AI, rather than a human." alt="" coords="16,379,115,405"/><area shape="rect" href="classAIClient.html" title="Simulated client driven by AI commands." alt="" coords="32,453,99,480"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classNetConnection-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a4000f32a9ef756449737b94fda64e9c8">checkMaxRate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensures that all configured packet rates and sizes meet minimum requirements.  <a href="#a4000f32a9ef756449737b94fda64e9c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a3289786db91c0e54a6ba552cb97db1d7">clearPaths</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On the server, resets the connection to indicate that mod paths have not been transmitted.  <a href="#a3289786db91c0e54a6ba552cb97db1d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a74510b72ca2cd9116d512341c78f4bf6">connect</a> (string remoteAddress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects to the remote address.  <a href="#a74510b72ca2cd9116d512341c78f4bf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a9a1f87965464ecff12b5f38a51740b36">connectLocal</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects with the server that is running within the same process as the client.  <a href="#a9a1f87965464ecff12b5f38a51740b36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a36094e8fb4028d1d042b85f9229eeece">getAddress</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the far end network address for the connection.  <a href="#a36094e8fb4028d1d042b85f9229eeece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a5e3cf212744568341187bf358338cbac">getGhostID</a> (int realID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On server or client, convert a real id to the ghost id for this connection.  <a href="#a5e3cf212744568341187bf358338cbac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a6f4367652c08cb4500bbb2758e8bdd46">getGhostsActive</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of active ghosts on the connection.  <a href="#a6f4367652c08cb4500bbb2758e8bdd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a25487d409472ac3e38199fe2f1af3c63">getPacketLoss</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the percentage of packets lost per tick.  <a href="#a25487d409472ac3e38199fe2f1af3c63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a2794fb68f7c0fb7584dc75a4423a2238">getPing</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the average round trip time (in ms) for the connection.  <a href="#a2794fb68f7c0fb7584dc75a4423a2238"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a542e84fd07e88fa93bb0aa5d6aefb85e">resolveGhostID</a> (int ghostID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On the client, convert a ghost ID from this connection to a real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID.  <a href="#a542e84fd07e88fa93bb0aa5d6aefb85e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a5e4fe0cc4fb3ccd8a4d635d2860290db">resolveObjectFromGhostIndex</a> (int ghostID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On the server, convert a ghost ID from this connection to a real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID.  <a href="#a5e4fe0cc4fb3ccd8a4d635d2860290db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a3dbd7e5bf450f6b3ce6325bab6634d2d">setSimulatedNetParams</a> (float packetLoss, int delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simulate network issues on the connection for testing.  <a href="#a3dbd7e5bf450f6b3ce6325bab6634d2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetConnection.html#a254626ba67b3feb6ec008a89ddf976ee">transmitPaths</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sent by the server during phase 2 of the mission download to update mod paths.  <a href="#a254626ba67b3feb6ec008a89ddf976ee"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides the basis for implementing a multiplayer game protocol. </p>
<p><a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> combines a low-level notify protocol implemented in ConnectionProtocol with a <a class="el" href="classSimGroup.html" title="A collection of SimObjects that are owned by the group.">SimGroup</a>, and implements several distinct subsystems:</p>
<ul>
<li><b>Event Manager</b> This is responsible for transmitting NetEvents over the wire. It deals with ensuring that the various types of NetEvents are delivered appropriately, and with notifying the event of its delivery status.</li>
</ul>
<ul>
<li><b>Move Manager</b> This is responsible for transferring a Move to the server 32 times a second (on the client) and applying it to the control object (on the server).</li>
</ul>
<ul>
<li><b>Ghost Manager</b> This is responsible for doing scoping calculations (on the server side) and transmitting most-recent ghost information to the client.</li>
</ul>
<ul>
<li><b>File Transfer</b> It is often the case that clients will lack important files when connecting to a server which is running a mod or new map. This subsystem allows the server to transfer such files to the client.</li>
</ul>
<ul>
<li><b>Networked String Table</b> String data can easily soak up network bandwidth, so for efficiency, we implement a networked string table. We can then notify the connection of strings we will reference often, such as player names, and transmit only a tag, instead of the whole string.</li>
</ul>
<ul>
<li><b>Demo Recording</b> A demo in Torque is a log of the network traffic between client and server; when a <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> records a demo, it simply logs this data to a file. When it plays a demo back, it replays the logged data.</li>
</ul>
<ul>
<li><b>Connection Database</b> This is used to keep track of all the NetConnections; it can be iterated over (for instance, to send an event to all active connections), or queried by address.</li>
</ul>
<p>The <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> is a <a class="el" href="classSimGroup.html" title="A collection of SimObjects that are owned by the group.">SimGroup</a>. On the client side, it contains all the objects which have been ghosted to that client. On the server side, it is empty; it can be used (typically in script) to hold objects related to the connection. For instance, you might place an observation camera in the NetConnnection. In both cases, when the connection is destroyed, so are the contained objects.</p>
<p>The <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> also has the concept of local connections. These are used when the client and server reside in the same process. A local connection is typically required to use the standard Torque world building tools. A local connection is also required when building a single player game.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Networking.html">Networking</a>, <a class="el" href="group__Networking.html">On Ghosting and Scoping</a>, <a class="el" href="group__Networking.html">Local Connections</a>, <a class="el" href="classGameConnection.html" title="The game-specific subclass of NetConnection.">GameConnection</a>, <a class="el" href="classAIConnection.html" title="Special client connection driven by an AI, rather than a human.">AIConnection</a>, and <a class="el" href="classAIClient.html" title="Simulated client driven by AI commands.">AIClient</a>. </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4000f32a9ef756449737b94fda64e9c8"></a><!-- doxytag: member="NetConnection::checkMaxRate" ref="a4000f32a9ef756449737b94fda64e9c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetConnection::checkMaxRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures that all configured packet rates and sizes meet minimum requirements. </p>
<p>This method is normally only called when a <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> class is first constructed. It need only be manually called if the global variables that set the packet rate or size have changed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If </dd></dl>
<dl class="rcs"><dt><b>pref</b></dt><dd>:Net::PacketRateToServer, </dd></dl>
<p>pref::Net::PacketRateToClient or <a class="el" href="group__Networking.html#ga45fc3ac31244802cf569187fa8b16997" title="Sets the maximum size in bytes an individual network packet may be.">$pref::Net::PacketSize</a> have been changed since a <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> has been created, this method must be called on all connections for them to follow the new rates or size. </p>

</div>
</div>
<a class="anchor" id="a3289786db91c0e54a6ba552cb97db1d7"></a><!-- doxytag: member="NetConnection::clearPaths" ref="a3289786db91c0e54a6ba552cb97db1d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetConnection::clearPaths </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On the server, resets the connection to indicate that mod paths have not been transmitted. </p>
<p>Typically when a mission has ended on the server, all connected clients are informed of this change and their connections are reset back to a starting state. This method resets a connection on the server to indicate that mod paths have not been transmitted.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="comment">// Inform the clients</span>
   <span class="keywordflow">for</span> (%clientIndex = 0; %clientIndex &lt; ClientGroup.getCount(); %clientIndex++)
   {
      <span class="comment">// clear ghosts and paths from all clients</span>
      %cl = ClientGroup.getObject(%clientIndex);
      %cl.endMission();
      %cl.resetGhosting();
      %cl.clearPaths();
   }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a74510b72ca2cd9116d512341c78f4bf6"></a><!-- doxytag: member="NetConnection::connect" ref="a74510b72ca2cd9116d512341c78f4bf6" args="(string remoteAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetConnection::connect </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>remoteAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to the remote address. </p>
<p>Attempts to connect with another <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> on the given address. Typically once connected, a game's information is passed along from the server to the client, followed by the player entering the game world. The actual procedure is dependent on the <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> subclass that is used. i.e. <a class="el" href="classGameConnection.html" title="The game-specific subclass of NetConnection.">GameConnection</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>remoteAddress</em>&nbsp;</td><td>The address to connect to in the form of IP:&lt;address&gt;:&lt;port although the <em>IP:</em> portion is optional. The <em>address</em> portion may be in the form of w.x.y.z or as a host name, in which case a DNS lookup will be performed. You may also substitue the word <em>broadcast</em> for the address to broadcast the connect request over the local subnet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classNetConnection.html#a9a1f87965464ecff12b5f38a51740b36" title="Connects with the server that is running within the same process as the client.">NetConnection::connectLocal()</a> to <a class="el" href="classNetConnection.html#a74510b72ca2cd9116d512341c78f4bf6" title="Connects to the remote address.">connect</a> to a server running within the same process as the client. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a1f87965464ecff12b5f38a51740b36"></a><!-- doxytag: member="NetConnection::connectLocal" ref="a9a1f87965464ecff12b5f38a51740b36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string NetConnection::connectLocal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects with the server that is running within the same process as the client. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error text message upon failure, or an empty string when successful.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <a class="el" href="group__Networking.html">Local Connections</a> for a description of local connections and their use. See <a class="el" href="classNetConnection.html#a74510b72ca2cd9116d512341c78f4bf6" title="Connects to the remote address.">NetConnection::connect()</a> to <a class="el" href="classNetConnection.html#a74510b72ca2cd9116d512341c78f4bf6" title="Connects to the remote address.">connect</a> to a server running in another process (on the same machine or not). </dd></dl>

</div>
</div>
<a class="anchor" id="a36094e8fb4028d1d042b85f9229eeece"></a><!-- doxytag: member="NetConnection::getAddress" ref="a36094e8fb4028d1d042b85f9229eeece" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string NetConnection::getAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the far end network address for the connection. </p>
<p>The address will be in one of the following forms:</p>
<ul>
<li><b>IP:Broadcast:&lt;port&gt;</b> for broadcast type addresses</li>
<li><b>IP:&lt;address&gt;:&lt;port&gt;</b> for IP addresses</li>
<li><b>local</b> when connected locally (server and client running in same process </li>
</ul>

</div>
</div>
<a class="anchor" id="a5e3cf212744568341187bf358338cbac"></a><!-- doxytag: member="NetConnection::getGhostID" ref="a5e3cf212744568341187bf358338cbac" args="(int realID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::getGhostID </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>realID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On server or client, convert a real id to the ghost id for this connection. </p>
<p>Torque's network ghosting system only exchanges ghost ID's between the server and client. Use this method on the server or client to discover an object's ghost ID based on its real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>realID</em>&nbsp;</td><td>The real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ghost ID of the object for this connection, or -1 if it could not be resolved.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Networking.html">On Ghosting and Scoping</a> for a description of the ghosting system. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f4367652c08cb4500bbb2758e8bdd46"></a><!-- doxytag: member="NetConnection::getGhostsActive" ref="a6f4367652c08cb4500bbb2758e8bdd46" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::getGhostsActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of active ghosts on the connection. </p>

</div>
</div>
<a class="anchor" id="a25487d409472ac3e38199fe2f1af3c63"></a><!-- doxytag: member="NetConnection::getPacketLoss" ref="a25487d409472ac3e38199fe2f1af3c63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::getPacketLoss </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the percentage of packets lost per tick. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is not yet hooked up. </dd></dl>

</div>
</div>
<a class="anchor" id="a2794fb68f7c0fb7584dc75a4423a2238"></a><!-- doxytag: member="NetConnection::getPing" ref="a2794fb68f7c0fb7584dc75a4423a2238" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::getPing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the average round trip time (in ms) for the connection. </p>
<p>The round trip time is recalculated every time a notify packet is received. Notify packets are used to information the connection that the far end successfully received the sent packet. </p>

</div>
</div>
<a class="anchor" id="a542e84fd07e88fa93bb0aa5d6aefb85e"></a><!-- doxytag: member="NetConnection::resolveGhostID" ref="a542e84fd07e88fa93bb0aa5d6aefb85e" args="(int ghostID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::resolveGhostID </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghostID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On the client, convert a ghost ID from this connection to a real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID. </p>
<p>Torque's network ghosting system only exchanges ghost ID's between the server and client. Use this method on the client to discover an object's local <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID when you only have a ghost ID. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ghostID</em>&nbsp;</td><td>The ghost ID of the object as sent by the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID of the object, or 0 if it could not be resolved.</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">%<span class="keywordtype">object</span> = ServerConnection.resolveGhostID( %ghostId );
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Networking.html">On Ghosting and Scoping</a> for a description of the ghosting system. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e4fe0cc4fb3ccd8a4d635d2860290db"></a><!-- doxytag: member="NetConnection::resolveObjectFromGhostIndex" ref="a5e4fe0cc4fb3ccd8a4d635d2860290db" args="(int ghostID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetConnection::resolveObjectFromGhostIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghostID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On the server, convert a ghost ID from this connection to a real <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID. </p>
<p>Torque's network ghosting system only exchanges ghost ID's between the server and client. Use this method on the server to discover an object's local <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID when you only have a ghost ID. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ghostID</em>&nbsp;</td><td>The ghost ID of the object as sent by the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a> ID of the object, or 0 if it could not be resolved.</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">%<span class="keywordtype">object</span> = %client.resolveObjectFromGhostIndex( %ghostId );
</pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Networking.html">On Ghosting and Scoping</a> for a description of the ghosting system. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dbd7e5bf450f6b3ce6325bab6634d2d"></a><!-- doxytag: member="NetConnection::setSimulatedNetParams" ref="a3dbd7e5bf450f6b3ce6325bab6634d2d" args="(float packetLoss, int delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetConnection::setSimulatedNetParams </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>packetLoss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simulate network issues on the connection for testing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packetLoss</em>&nbsp;</td><td>The fraction of packets that will be lost. Ranges from 0.0 (no loss) to 1.0 (complete loss) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>Delays packets being transmitted by simulating a particular ping. This is an absolute integer, measured in ms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a254626ba67b3feb6ec008a89ddf976ee"></a><!-- doxytag: member="NetConnection::transmitPaths" ref="a254626ba67b3feb6ec008a89ddf976ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetConnection::transmitPaths </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sent by the server during phase 2 of the mission download to update mod paths. </p>
<p>Mod paths on the client need to be in sync with the server prior to objects being ghosted. This is typically done during the standard mission start phase 2 when following Torque's example mission startup sequence.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
{
   <span class="comment">// Make sure to ignore calls from a previous mission load</span>
   <span class="keywordflow">if</span> (%seq != $missionSequence || !$MissionRunning)
      <span class="keywordflow">return</span>;
   <span class="keywordflow">if</span> (%client.currentPhase != 1.5)
      <span class="keywordflow">return</span>;
   %client.currentPhase = 2;

   <span class="comment">// Set the player datablock choice</span>
   %client.playerDB = %playerDB;

   <span class="comment">// Update mod paths, this needs to get there before the objects.</span>
   %client.transmitPaths();

   <span class="comment">// Start ghosting objects to the client</span>
   %client.activateGhosting();
}
</pre></div> </dd></dl>

</div>
</div>
</div>

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
