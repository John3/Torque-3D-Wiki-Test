<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Torque 3D - Script Manual: Player Class Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" href="https://github.com/LuisAntonRebollo/Torque-3D-Wiki-Test/wiki">Wiki</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER -->
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>Player Class Reference<br/>
<small>
[<a class="el" href="group__gameObjects.html">Game Objects</a>]</small>
</h1><!-- doxytag: class="Player" --><!-- doxytag: inherits="ShapeBase" -->
<p>A client-controlled player character.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Player:</div>
<div class="dynsection">
<div class="center"><img src="classPlayer__inherit__graph.png" border="0" usemap="#Player_inherit__map" alt="Inheritance graph"/></div>
<map name="Player_inherit__map" id="Player_inherit__map">
<area shape="rect" href="classAIPlayer.html" title="A Player object not controlled by conventional input, but by an AI engine." alt="" coords="19,453,88,480"/><area shape="rect" href="classShapeBase.html" title="A scriptable, renderable shape." alt="" coords="9,304,97,331"/><area shape="rect" href="classGameBase.html" title="Base class for game objects which use datablocks, networking, are editable, and need..." alt="" coords="11,229,96,256"/><area shape="rect" href="classSceneObject.html" title="A networkable object that exists in the 3D world." alt="" coords="5,155,101,181"/><area shape="rect" href="classNetObject.html" title="Superclass for all ghostable networked objects." alt="" coords="13,80,93,107"/><area shape="rect" href="classSimObject.html" title="Base class for almost all objects involved in the simulation." alt="" coords="12,5,95,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classPlayer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a08297b8517d0876c7b1ee449e71c2b7e">checkDismountPoint</a> (Point3F oldPos, Point3F pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if it is safe to dismount at this position.  <a href="#a08297b8517d0876c7b1ee449e71c2b7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#ada70910b56f162d2cb0ce478d6ee1312">clearControlObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the player's current control object.  <a href="#ada70910b56f162d2cb0ce478d6ee1312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a796ee9e35a9a7e8269882b579351b9ea">getControlObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current object we are controlling.  <a href="#a796ee9e35a9a7e8269882b579351b9ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a4e30d845c50351bb96be0579dd323a8a">getDamageLocation</a> (Point3F pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the named damage location and modifier for a given world position.  <a href="#a4e30d845c50351bb96be0579dd323a8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a3cbe806db4bbc8d2331e05707bd85987">getState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the player's current state.  <a href="#a3cbe806db4bbc8d2331e05707bd85987"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#ad1b12d593e7feb4c76866c889f05d95a">setActionThread</a> (string <a class="el" href="classSimObject.html#a91770ca6289d3166809997c44c64ad2f">name</a>, bool hold=false, bool fsp=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the main action sequence to play for this player.  <a href="#ad1b12d593e7feb4c76866c889f05d95a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a9a9a39112a007c9a07256ca7f80fca71">setArmThread</a> (string <a class="el" href="classSimObject.html#a91770ca6289d3166809997c44c64ad2f">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sequence that controls the player's arms (dynamically adjusted to match look direction).  <a href="#a9a9a39112a007c9a07256ca7f80fca71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a58150632f7766abaacab337835551674">setControlObject</a> (<a class="el" href="classShapeBase.html">ShapeBase</a> obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the object to be controlled by this player.  <a href="#a58150632f7766abaacab337835551674"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a8510c27ec0b777af5764dffa1e6adeb4">isRenderable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables rendering of all instances of this type.  <a href="#a8510c27ec0b777af5764dffa1e6adeb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a1d15e9cc5d568a5ad430b37146786699">isSelectable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables selection of all instances of this type.  <a href="#a1d15e9cc5d568a5ad430b37146786699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a0dc479fdb67aec8a55894719b48f8a0b">maxPredictionTicks</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of ticks to predict on the client from the last known move obtained from the server.  <a href="#a0dc479fdb67aec8a55894719b48f8a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a279988bb16cd613c67c60c14a409c6bd">maxWarpTicks</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When a warp needs to occur due to the client being too far off from the server, this is the maximum number of ticks we'll allow the client to warp to catch up.  <a href="#a279988bb16cd613c67c60c14a409c6bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#abc0c7a93eb882b1f6b19cd816b4288a8">minWarpTicks</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fraction of tick at which instant warp occures on the client.  <a href="#abc0c7a93eb882b1f6b19cd816b4288a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a1bce1e347122ec4f87c641a639c24f76">renderCollision</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the player's collision mesh should be rendered.  <a href="#a1bce1e347122ec4f87c641a639c24f76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#a0170af39407077c9559b1054f4ba3b12">renderMyItems</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if mounted shapes are rendered or not.  <a href="#a0170af39407077c9559b1054f4ba3b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlayer.html#aea29af6f0b5f728b46ed675483bf7a2a">renderMyPlayer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the player is rendered or not.  <a href="#aea29af6f0b5f728b46ed675483bf7a2a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A client-controlled player character. </p>
<p>The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> object is the main client-controlled object in an FPS, or indeed, any game where the user is in control of a single character. This class (and the associated datablock, <a class="el" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a>) allows you to fine-tune the movement, collision detection, animation, and SFX properties of the character. <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> derives from <a class="el" href="classShapeBase.html" title="A scriptable, renderable shape.">ShapeBase</a>, so it is recommended to have a good understanding of that class (and it's parent classes) as well.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSceneObject.html" title="A networkable object that exists in the 3D world.">SceneObject</a> </dd>
<dd>
<a class="el" href="classGameBase.html" title="Base class for game objects which use datablocks, networking, are editable, and need...">GameBase</a> </dd>
<dd>
<a class="el" href="classShapeBase.html" title="A scriptable, renderable shape.">ShapeBase</a> </dd>
<dd>
<a class="el" href="classShapeBaseImageData.html" title="Represents geometry to be mounted to a ShapeBase object.">ShapeBaseImageData</a></dd></dl>
<h2>Movement</h2>
<p>The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> class supports the following modes of movement, known as poses:</p>
<ul>
<li>
Stand </li>
<li>
Crouching </li>
<li>
Prone </li>
<li>
Swimming </li>
</ul>
<p>The acceleration, maximum speed, and bounding box for each mode can be set independently using the <a class="el" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a> datablock. The player will automatically switch between swimming and one of the other 3 'dry' modes when entering/exiting the water, but transitions between the non-swimming modes are handled by controller input (such as holding down a key to begin crouching). $mvTriggerCount3 activates crouching, while $mvTriggerCount4 activates being prone.</p>
<p>It is important to set the bounding box correctly for each mode so that collisions with the player remain accurate:</p>
<div align="center">
<img src="images/player_bbox.png" alt="player_bbox.png"/>
</div>
<h2>Jumping</h2>
<p>The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> class supports jumping. While the player is in contact with a surface (and optionally has enough energy as defined by the <a class="el" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a>), $mvTriggerCount2 will cause the player to jump.</p>
<h2>Jetting</h2>
<p>The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> class includes a simple jetpack behaviour allowing characters to 'jet' upwards while jumping. The jetting behaviour can be linked to the player's energy level using datablock properties as shown below:</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">datablock <a class="code" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a>( JetPlayer )
{
   ...

   jetJumpForce = 16.0 * 90;
   jetJumpEnergyDrain = 10;
   jetMinJumpEnergy = 25;
   jetMinJumpSpeed = 20;
   jetMaxJumpSpeed = 100;
   jetJumpSurfaceAngle = 78;
}
</pre></div></dd></dl>
<p>This player will not be able to jet if he has less than 25 units of energy, and 10 units will be subtracted each tick.</p>
<p>If PlayerData::jetJumpFore is greater than zero then $mvTriggerCount1 will activate jetting.</p>
<h2>Air Control</h2>
<p>The player may optionally move itself through the air while jumping or falling. This allows the player to adjust their trajectory while in the air, and is known as air control. The <a class="el" href="classPlayerData.html#a31c85023a4dabae4058ee8e9d2f4265a" title="Amount of movement control the player has when in the air.">PlayerData::airControl</a> property determines what fraction of the player's normal speed they may move while in the air. By default, air control is disabled (set to 0).</p>
<h2>Dismounting</h2>
<p>It is possible to have the player mount another object, such as a vehicle, just like any other <a class="el" href="classSceneObject.html" title="A networkable object that exists in the 3D world.">SceneObject</a>. While mounted, $mvTriggerCount2 will cause the player to dismount.</p>
<h2>Triggering a Mounted Object</h2>
<p>A <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> may have other objects mounted to it, with each mounted object assigned to a slot. These <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> mounted objects are known as images. See <a class="el" href="classShapeBase.html#ab003698139f63c896284ac355c7aa7c2" title="Mount a new Image.">ShapeBase::mountImage()</a>. If there is an image mounted to slot 0, $mvTriggerCount0 will trigger it. If the player dies this trigger is automatically released.</p>
<p>If there is an image mounted to slot 1, $mvTriggerCount1 will trigger it. Otherwise $mvTriggerCount1 will be passed along to the image in slot 0 as an alternate fire state.</p>
<h2>Character model</h2>
<p>The following sequences are used by the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> object to animate the character. Not all of them are required, but a model should have at least the root, run, back and side animations.</p>
<dl>
<dt>root</dt>
<dd>Looping sequence played when player is standing but not moving. </dd>
<dt>run</dt>
<dd>Looping sequence played when player is running forward. </dd>
<dt>back</dt>
<dd>Looping sequence played when player is running backward. </dd>
<dt>side</dt>
<dd>Looping sequence played when player is running sideways (strafing). The sequence should depict the player moving left. If side_right is not present, this sequence will be played backwards in its place. </dd>
<dt>side_right</dt>
<dd><p class="startdd">Looping sequence played when player is running sideways right.</p>
<p class="enddd"></p>
</dd>
<dt>crouch_root</dt>
<dd>Looping sequence played when player is crouched and not moving. </dd>
<dt>crouch_forward</dt>
<dd>Looping sequence played when player is crouched and moving forward. </dd>
<dt>crouch_backward</dt>
<dd>Looping sequence played when player is crouched and moving backward. </dd>
<dt>crouch_side</dt>
<dd>Looping sequence played when player is crouched and moving sideways. The sequence should depict the player moving left. If crouch_right is not present, this sequence will be played backwards in its place. </dd>
<dt>crouch_right</dt>
<dd><p class="startdd">Looping sequence played when player is crouched and moving sideways.</p>
<p class="enddd"></p>
</dd>
<dt>prone_root</dt>
<dd>Looping sequence played when player is prone (lying down) and not moving. </dd>
<dt>prone_forward</dt>
<dd>Looping sequence played when player is prone (lying down) and moving forward. </dd>
<dt>prone_backward</dt>
<dd><p class="startdd">Looping sequence played when player is prone (lying down) and moving backward.</p>
<p class="enddd"></p>
</dd>
<dt>swim_root</dt>
<dd>Looping sequence played when player is swimming and not moving. </dd>
<dt>swim_forward</dt>
<dd>Looping sequence played when player is swimming and moving forward. </dd>
<dt>swim_backward</dt>
<dd>Looping sequence played when player is swimming and moving backward. </dd>
<dt>swim_left</dt>
<dd>Looping sequence played when player is swimming and moving left. The sequence should depict the player moving left. If swim_right is not present, this sequence will be played backwards in its place. </dd>
<dt>swim_right</dt>
<dd><p class="startdd">Looping sequence played when player is swimming and moving right.</p>
<p class="enddd"></p>
</dd>
<dt>fall</dt>
<dd>Sequence played when player is falling. </dd>
<dt>jump</dt>
<dd>Sequence played when player has jumped while moving. </dd>
<dt>standjump</dt>
<dd>Sequence played when player has jumped from a standing start. </dd>
<dt>land</dt>
<dd>Sequence played when player lands after falling. </dd>
<dt>jet</dt>
<dd><p class="startdd">Looping sequence played when player is jetting.</p>
<p class="enddd"></p>
</dd>
<dt>head</dt>
<dd>Sequence to control vertical head movement (for looking) (start=full up, end=full down). </dd>
<dt>headside</dt>
<dd>Sequence to control horizontal head movement (for looking) (start=full left, end=full right). </dd>
<dt>look</dt>
<dd><p class="startdd">Sequence to control vertical arm movement (for looking) (start=full up, end=full down).</p>
<p class="enddd"></p>
</dd>
<dt>light_recoil</dt>
<dd>Sequence played when the player is firing a light weapon. (Based on <a class="el" href="classShapeBaseImageData.html" title="Represents geometry to be mounted to a ShapeBase object.">ShapeBaseImageData</a>) </dd>
<dt>medium_recoil</dt>
<dd>Sequence played when player is firing a medium weapon. (Based on <a class="el" href="classShapeBaseImageData.html" title="Represents geometry to be mounted to a ShapeBase object.">ShapeBaseImageData</a>) </dd>
<dt>heavy_recoil</dt>
<dd><p class="startdd">Sequence played when player is firing a heavy weapon (Based on <a class="el" href="classShapeBaseImageData.html" title="Represents geometry to be mounted to a ShapeBase object.">ShapeBaseImageData</a>).</p>
<p class="enddd"></p>
</dd>
<dt>deathN</dt>
<dd>Sequence played when player has been killed (a random one of these will play). N is an integer from 1 to 11. </dd>
</dl>
<p>An example of a player datablock appears below:</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">datablock <a class="code" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a>( BasicPlayerData )
{
   renderFirstPerson = <span class="keyword">true</span>;

   shapeFile = <span class="stringliteral">&quot;art/shapes/actors/gideon/gideon.dts&quot;</span>;
   computeCRC = <span class="keyword">true</span>;

   cameraDefaultFov = 100.0;
   cameraMinFov = 5.0;
   cameraMaxFov = 120.0;
   cameraMaxDist = 3;

   debrisShapeName = <span class="stringliteral">&quot;art/shapes/actors/common/debris_player.dts&quot;</span>;
   debris = PlayerDebris;

   aiAvoidThis = <span class="keyword">true</span>;

   minLookAngle = -1.4;
   maxLookAngle = 1.4;
   maxFreelookAngle = 3.0;

   mass = 100;
   drag = 1.3;
   maxdrag = 0.4;
   density = 1.1;
   maxDamage = 100;
   maxEnergy =  60;
   repairRate = 0.33;
   energyPerDamagePoint = 75.0;
   rechargeRate = 0.256;

   <span class="comment">// Running</span>
   runForce = 48 * 90;
   runEnergyDrain = 0;
   minRunEnergy = 0;
   maxForwardSpeed = 8;
   maxBackwardSpeed = 6;
   maxSideSpeed = 6;
   %<a class="code" href="classGameBase.html#aaf05555b1abaa0d0a71ae2cf9519e099" title="Toggles on the rendering of the bounding boxes for certain types of objects in scene...">boundingBox</a> = <span class="stringliteral">&quot;1 1 2&quot;</span>;

   <span class="comment">// Crouching</span>
   crouchForce = 45.0 * 9.0;
   maxCrouchForwardSpeed = 4.0;
   maxCrouchBackwardSpeed = 2.0;
   maxCrouchSideSpeed = 2.0;
   crouchBoundingBox = <span class="stringliteral">&quot;1 1 1.5&quot;</span>;

   <span class="comment">// Prone</span>
   proneForce = 45.0 * 9.0;
   maxProneForwardSpeed = 4.0;
   maxProneBackwardSpeed = 2.0;
   maxProneSideSpeed = 2.0;
   proneBoundingBox = <span class="stringliteral">&quot;1 2 1&quot;</span>;

   <span class="comment">// Underwater</span>
   maxUnderwaterForwardSpeed = 8.4;
   maxUnderwaterBackwardSpeed = 7.8;
   maxUnderwaterSideSpeed = 7.8;
   swimBoundingBox = <span class="stringliteral">&quot;1 2 2&quot;</span>;

   <span class="comment">// Jumping</span>
   jumpForce = 8.3 * 90;
   jumpEnergyDrain = 0;
   minJumpEnergy = 0;
   jumpDelay = 15;
   airControl = 0.3;

   recoverDelay = 9;
   recoverRunForceScale = 1.2;

   minImpactSpeed = 45;
   speedDamageScale = 0.4;

   pickupRadius = 0.75;

   <span class="comment">// Damage location details</span>
   boxNormalHeadPercentage       = 0.83;
   boxNormalTorsoPercentage      = 0.49;
   boxHeadLeftPercentage         = 0;
   boxHeadRightPercentage        = 1;
   boxHeadBackPercentage         = 0;
   boxHeadFrontPercentage        = 1;

   <span class="comment">// Foot Prints</span>
   decalData   = PlayerFootprint;
   decalOffset = 0.25;

   footPuffEmitter = LightPuffEmitter;
   footPuffNumParts = 10;
   footPuffRadius = 0.25;

   dustEmitter = LiftoffDustEmitter;

   splash = PlayerSplash;
   splashVelocity = 4.0;
   splashAngle = 67.0;
   splashFreqMod = 300.0;
   splashVelEpsilon = 0.60;
   bubbleEmitTime = 0.4;
   splashEmitter[0] = PlayerWakeEmitter;
   splashEmitter[1] = PlayerFoamEmitter;
   splashEmitter[2] = PlayerBubbleEmitter;
   mediumSplashSoundVelocity = 10.0;
   hardSplashSoundVelocity = 20.0;
   exitSplashSoundVelocity = 5.0;

   <span class="comment">// Control slope of runnable/jumpable surfaces</span>
   runSurfaceAngle  = 70;
   jumpSurfaceAngle = 80;
   maxStepHeight = 1.5;  <span class="comment">// two meters</span>
   minJumpSpeed = 20;
   maxJumpSpeed = 30;

   horizMaxSpeed = 68;
   horizResistSpeed = 33;
   horizResistFactor = 0.35;

   upMaxSpeed = 80;
   upResistSpeed = 25;
   upResistFactor = 0.3;

   footstepSplashHeight = 0.35;

   <span class="comment">// Footstep Sounds</span>
   FootSoftSound        = FootLightSoftSound;
   FootHardSound        = FootLightHardSound;
   FootMetalSound       = FootLightMetalSound;
   FootSnowSound        = FootLightSnowSound;
   FootShallowSound     = FootLightShallowSplashSound;
   FootWadingSound      = FootLightWadingSound;
   FootUnderwaterSound  = FootLightUnderwaterSound;

   FootBubblesSound     = FootLightBubblesSound;
   movingBubblesSound   = PlayerMoveBubblesSound;
   waterBreathSound     = WaterBreathMaleSound;

   impactSoftSound      = ImpactLightSoftSound;
   impactHardSound      = ImpactLightHardSound;
   impactMetalSound     = ImpactLightMetalSound;
   impactSnowSound      = ImpactLightSnowSound;

   impactWaterEasy      = ImpactLightWaterEasySound;
   impactWaterMedium    = ImpactLightWaterMediumSound;
   impactWaterHard      = ImpactLightWaterHardSound;
   exitingWater         = ExitingWaterLightSound;

   groundImpactMinSpeed    = 10.0;
   groundImpactShakeFreq   = <span class="stringliteral">&quot;4.0 4.0 4.0&quot;</span>;
   groundImpactShakeAmp    = <span class="stringliteral">&quot;1.0 1.0 1.0&quot;</span>;
   groundImpactShakeDuration = 0.8;
   groundImpactShakeFalloff = 10.0;
};
</pre></div> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a08297b8517d0876c7b1ee449e71c2b7e"></a><!-- doxytag: member="Player::checkDismountPoint" ref="a08297b8517d0876c7b1ee449e71c2b7e" args="(Point3F oldPos, Point3F pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Player::checkDismountPoint </td>
          <td>(</td>
          <td class="paramtype">Point3F&nbsp;</td>
          <td class="paramname"> <em>oldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point3F&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if it is safe to dismount at this position. </p>
<p>Internally this method casts a ray from oldPos to pos to determine if it hits the terrain, an interior object, a water object, another player, a static shape, a vehicle (exluding the one currently mounted), or physical zone. If this ray is in the clear, then the player's bounding box is also checked for a collision at the pos position. If this displaced bounding box is also in the clear, then <a class="el" href="classPlayer.html#a08297b8517d0876c7b1ee449e71c2b7e" title="Check if it is safe to dismount at this position.">checkDismountPoint()</a> returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPos</em>&nbsp;</td><td>The player's current position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The dismount position to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the dismount position is clear, false if not </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The player must be already mounted for this method to not assert. </dd></dl>

</div>
</div>
<a class="anchor" id="ada70910b56f162d2cb0ce478d6ee1312"></a><!-- doxytag: member="Player::clearControlObject" ref="ada70910b56f162d2cb0ce478d6ee1312" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Player::clearControlObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the player's current control object. </p>
<p>Returns control to the player. This internally calls Player::setControlObject(0). </p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">%player.clearControlObject();
<a class="code" href="group__Logging.html#gadda60a90d6b71f2d19f027847c0cb6f9" title="Logs a message to the console.">echo</a>(%player.getControlObject()); <span class="comment">//&lt;-- Returns 0, player assumes control</span>
%player.setControlObject(%vehicle);
<a class="code" href="group__Logging.html#gadda60a90d6b71f2d19f027847c0cb6f9" title="Logs a message to the console.">echo</a>(%player.getControlObject()); <span class="comment">//&lt;-- Returns %vehicle, player controls the vehicle now.</span>
</pre></div></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the player does not have a control object, the player will receive all moves from its <a class="el" href="classGameConnection.html" title="The game-specific subclass of NetConnection.">GameConnection</a>. If you're looking to remove control from the player itself (i.e. stop sending moves to the player) use <a class="el" href="classGameConnection.html#ae800c6b8f44fa569060447c7ab4ec3f6" title="On the server, sets the object that the client will control.">GameConnection::setControlObject()</a> to transfer control to another object, such as a camera. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPlayer.html#a58150632f7766abaacab337835551674" title="Set the object to be controlled by this player.">setControlObject()</a> </dd>
<dd>
<a class="el" href="classPlayer.html#a796ee9e35a9a7e8269882b579351b9ea" title="Get the current object we are controlling.">getControlObject()</a> </dd>
<dd>
<a class="el" href="classGameConnection.html#ae800c6b8f44fa569060447c7ab4ec3f6" title="On the server, sets the object that the client will control.">GameConnection::setControlObject()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a796ee9e35a9a7e8269882b579351b9ea"></a><!-- doxytag: member="Player::getControlObject" ref="a796ee9e35a9a7e8269882b579351b9ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Player::getControlObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current object we are controlling. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of the <a class="el" href="classShapeBase.html" title="A scriptable, renderable shape.">ShapeBase</a> object we control, or 0 if not controlling an object. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPlayer.html#a58150632f7766abaacab337835551674" title="Set the object to be controlled by this player.">setControlObject()</a> </dd>
<dd>
<a class="el" href="classPlayer.html#ada70910b56f162d2cb0ce478d6ee1312" title="Clears the player&#39;s current control object.">clearControlObject()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e30d845c50351bb96be0579dd323a8a"></a><!-- doxytag: member="Player::getDamageLocation" ref="a4e30d845c50351bb96be0579dd323a8a" args="(Point3F pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Player::getDamageLocation </td>
          <td>(</td>
          <td class="paramtype">Point3F&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the named damage location and modifier for a given world position. </p>
<p>the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> object can simulate different hit locations based on a pre-defined set of <a class="el" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a> defined percentages. These hit percentages divide up the Player's bounding box into different regions. The diagram below demonstrates how the various <a class="el" href="classPlayerData.html" title="Defines properties for a Player object.">PlayerData</a> properties split up the bounding volume:</p>
<div align="center">
<img src="images/player_damageloc.png" alt="player_damageloc.png"/>
</div>
<p>While you may pass in any world position and <a class="el" href="classPlayer.html#a4e30d845c50351bb96be0579dd323a8a" title="Get the named damage location and modifier for a given world position.">getDamageLocation()</a> will provide a best-fit location, you should be aware that this can produce some interesting results. For example, any position that is above <a class="el" href="classPlayerData.html#a60425ecbba57bbda8cc3e3b287d6d5e5" title="Percentage of the player&#39;s bounding box height that represents the head.">PlayerData::boxHeadPercentage</a> will be considered a 'head' hit, even if the world position is high in the sky. Therefore it may be wise to keep the passed in point to somewhere on the surface of, or within, the Player's bounding volume.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method will not return an accurate location when the player is prone or swimming.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>A world position for which to retrieve a body region on this player. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing two words (space separated strings), where the first is a location and the second is a modifier.</dd></dl>
<p>Posible locations:</p>
<ul>
<li>
head</li>
<li>
torso</li>
<li>
legs</li>
</ul>
<p>Head modifiers:</p>
<ul>
<li>
left_back</li>
<li>
middle_back</li>
<li>
right_back</li>
<li>
left_middle</li>
<li>
middle_middle</li>
<li>
right_middle</li>
<li>
left_front</li>
<li>
middle_front</li>
<li>
right_front</li>
</ul>
<p>Legs/Torso modifiers:</p>
<ul>
<li>
front_left</li>
<li>
front_right</li>
<li>
back_left</li>
<li>
back_right</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPlayerData.html#a60425ecbba57bbda8cc3e3b287d6d5e5" title="Percentage of the player&#39;s bounding box height that represents the head.">PlayerData::boxHeadPercentage</a> </dd>
<dd>
<a class="el" href="classPlayerData.html#af8c907907e107426f4b5648b9f12950a" title="Percentage of the player&#39;s bounding box depth that represents the front side...">PlayerData::boxHeadFrontPercentage</a> </dd>
<dd>
<a class="el" href="classPlayerData.html#a4330f6ed42b30f0af3864ace59a91c9b" title="Percentage of the player&#39;s bounding box depth that represents the back side of...">PlayerData::boxHeadBackPercentage</a> </dd>
<dd>
<a class="el" href="classPlayerData.html#a744bff8a5e09bd11b625a7117a380789" title="Percentage of the player&#39;s bounding box width that represents the left side of...">PlayerData::boxHeadLeftPercentage</a> </dd>
<dd>
<a class="el" href="classPlayerData.html#a874100fd809447570894162c1241e41a" title="Percentage of the player&#39;s bounding box width that represents the right side...">PlayerData::boxHeadRightPercentage</a> </dd>
<dd>
<a class="el" href="classPlayerData.html#ab456dc81a8e24f9815623228167684ec" title="Percentage of the player&#39;s bounding box height that represents the torso.">PlayerData::boxTorsoPercentage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3cbe806db4bbc8d2331e05707bd85987"></a><!-- doxytag: member="Player::getState" ref="a3cbe806db4bbc8d2331e05707bd85987" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Player::getState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of the player's current state. </p>
<p>The state is one of the following:</p>
<ul>
<li>
Dead - The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> is dead.</li>
<li>
Mounted - The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> is mounted to an object such as a vehicle.</li>
<li>
Move - The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> is free to move. The usual state.</li>
<li>
Recover - The <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> is recovering from a fall. See <a class="el" href="classPlayerData.html#a694fd522257e9f2e19cfb944f27d7cd9" title="Number of ticks for the player to recover from falling.">PlayerData::recoverDelay</a>.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current state; one of: "Dead", "Mounted", "Move", "Recover" </dd></dl>

</div>
</div>
<a class="anchor" id="ad1b12d593e7feb4c76866c889f05d95a"></a><!-- doxytag: member="Player::setActionThread" ref="ad1b12d593e7feb4c76866c889f05d95a" args="(string name, bool hold=false, bool fsp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Player::setActionThread </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fsp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the main action sequence to play for this player. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the action sequence to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hold</em>&nbsp;</td><td>Set to false to get a callback on the datablock when the sequence ends (<a class="el" href="classPlayerData.html#a5cd4ca581192ffeb92bd880a00a594a6" title="Called on the server when a scripted animation completes.">PlayerData::animationDone()</a>). When set to true no callback is made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fsp</em>&nbsp;</td><td>True if first person and none of the spine nodes in the shape should animate. False will allow the shape's spine nodes to animate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if succesful, false if failed </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The spine nodes for the Player's shape are named as follows:</dd></dl>
<ul>
<li>
Bip01 Pelvis</li>
<li>
Bip01 Spine</li>
<li>
Bip01 Spine1</li>
<li>
Bip01 Spine2</li>
<li>
Bip01 Neck</li>
<li>
Bip01 Head</li>
</ul>
<p>You cannot use <a class="el" href="classPlayer.html#ad1b12d593e7feb4c76866c889f05d95a" title="Set the main action sequence to play for this player.">setActionThread()</a> to have the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> play one of the motion determined action animation sequences. These sequences are chosen based on how the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> moves and the Player's current pose. The names of these sequences are:</p>
<ul>
<li>
root</li>
<li>
run</li>
<li>
side</li>
<li>
side_right</li>
<li>
crouch_root</li>
<li>
crouch_forward</li>
<li>
crouch_backward</li>
<li>
crouch_side</li>
<li>
crouch_right</li>
<li>
prone_root</li>
<li>
prone_forward</li>
<li>
prone_backward</li>
<li>
swim_root</li>
<li>
swim_forward</li>
<li>
swim_backward</li>
<li>
swim_left</li>
<li>
swim_right</li>
<li>
fall</li>
<li>
jump</li>
<li>
standjump</li>
<li>
land</li>
<li>
jet</li>
</ul>
<p>If the player moves in any direction then the animation sequence set using this method will be cancelled and the chosen mation-based sequence will take over. This makes great for times when the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> cannot move, such as when mounted, or when it doesn't matter if the action sequence changes, such as waving and saluting. </p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"><span class="comment">// Place the player in a sitting position after being mounted</span>
%player.setActionThread( <span class="stringliteral">&quot;sitting&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span> );
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a9a39112a007c9a07256ca7f80fca71"></a><!-- doxytag: member="Player::setArmThread" ref="a9a9a39112a007c9a07256ca7f80fca71" args="(string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Player::setArmThread </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the sequence that controls the player's arms (dynamically adjusted to match look direction). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the sequence to play on the player's arms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, false if failed. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>By default the 'look' sequence is used, if available. </dd></dl>

</div>
</div>
<a class="anchor" id="a58150632f7766abaacab337835551674"></a><!-- doxytag: member="Player::setControlObject" ref="a58150632f7766abaacab337835551674" args="(ShapeBase obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Player::setControlObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShapeBase.html">ShapeBase</a>&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the object to be controlled by this player. </p>
<p>It is possible to have the moves sent to the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> object from the <a class="el" href="classGameConnection.html" title="The game-specific subclass of NetConnection.">GameConnection</a> to be passed along to another object. This happens, for example when a player is mounted to a vehicle. The move commands pass through the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> and on to the vehicle (while the player remains stationary within the vehicle). With <a class="el" href="classPlayer.html#a58150632f7766abaacab337835551674" title="Set the object to be controlled by this player.">setControlObject()</a> you can have the <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> pass along its moves to any object. One possible use is for a player to move a remote controlled vehicle. In this case the player does not mount the vehicle directly, but still wants to be able to control it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>Object to control with this player </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the object is valid, false if not </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPlayer.html#a796ee9e35a9a7e8269882b579351b9ea" title="Get the current object we are controlling.">getControlObject()</a> </dd>
<dd>
<a class="el" href="classPlayer.html#ada70910b56f162d2cb0ce478d6ee1312" title="Clears the player&#39;s current control object.">clearControlObject()</a> </dd>
<dd>
<a class="el" href="classGameConnection.html#ae800c6b8f44fa569060447c7ab4ec3f6" title="On the server, sets the object that the client will control.">GameConnection::setControlObject()</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a8510c27ec0b777af5764dffa1e6adeb4"></a><!-- doxytag: member="Player::isRenderable" ref="a8510c27ec0b777af5764dffa1e6adeb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPlayer.html#a8510c27ec0b777af5764dffa1e6adeb4">Player::isRenderable</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables rendering of all instances of this type. </p>

<p>Reimplemented from <a class="el" href="classShapeBase.html#a73d23aae73f43b0c20e95dadc135f067">ShapeBase</a>.</p>

<p>Reimplemented in <a class="el" href="classAIPlayer.html#a80b797e4f020ab5566710f814fd4382d">AIPlayer</a>.</p>

</div>
</div>
<a class="anchor" id="a1d15e9cc5d568a5ad430b37146786699"></a><!-- doxytag: member="Player::isSelectable" ref="a1d15e9cc5d568a5ad430b37146786699" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPlayer.html#a1d15e9cc5d568a5ad430b37146786699">Player::isSelectable</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables selection of all instances of this type. </p>

<p>Reimplemented from <a class="el" href="classShapeBase.html#a57128b68165ea0c189510690671f6e18">ShapeBase</a>.</p>

<p>Reimplemented in <a class="el" href="classAIPlayer.html#a33c88f0907474982bf7163cfbd5d2315">AIPlayer</a>.</p>

</div>
</div>
<a class="anchor" id="a0dc479fdb67aec8a55894719b48f8a0b"></a><!-- doxytag: member="Player::maxPredictionTicks" ref="a0dc479fdb67aec8a55894719b48f8a0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPlayer.html#a0dc479fdb67aec8a55894719b48f8a0b">Player::maxPredictionTicks</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of ticks to predict on the client from the last known move obtained from the server. </p>

</div>
</div>
<a class="anchor" id="a279988bb16cd613c67c60c14a409c6bd"></a><!-- doxytag: member="Player::maxWarpTicks" ref="a279988bb16cd613c67c60c14a409c6bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPlayer.html#a279988bb16cd613c67c60c14a409c6bd">Player::maxWarpTicks</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a warp needs to occur due to the client being too far off from the server, this is the maximum number of ticks we'll allow the client to warp to catch up. </p>

</div>
</div>
<a class="anchor" id="abc0c7a93eb882b1f6b19cd816b4288a8"></a><!-- doxytag: member="Player::minWarpTicks" ref="abc0c7a93eb882b1f6b19cd816b4288a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classPlayer.html#abc0c7a93eb882b1f6b19cd816b4288a8">Player::minWarpTicks</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fraction of tick at which instant warp occures on the client. </p>

</div>
</div>
<a class="anchor" id="a1bce1e347122ec4f87c641a639c24f76"></a><!-- doxytag: member="Player::renderCollision" ref="a1bce1e347122ec4f87c641a639c24f76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPlayer.html#a1bce1e347122ec4f87c641a639c24f76">Player::renderCollision</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the player's collision mesh should be rendered. </p>
<p>This is mainly used for the tools and debugging. </p>

</div>
</div>
<a class="anchor" id="a0170af39407077c9559b1054f4ba3b12"></a><!-- doxytag: member="Player::renderMyItems" ref="a0170af39407077c9559b1054f4ba3b12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPlayer.html#a0170af39407077c9559b1054f4ba3b12">Player::renderMyItems</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if mounted shapes are rendered or not. </p>
<p>Used on the client side to disable the rendering of all <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> mounted objects. This is mainly used for the tools or debugging. </p>

</div>
</div>
<a class="anchor" id="aea29af6f0b5f728b46ed675483bf7a2a"></a><!-- doxytag: member="Player::renderMyPlayer" ref="aea29af6f0b5f728b46ed675483bf7a2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPlayer.html#aea29af6f0b5f728b46ed675483bf7a2a">Player::renderMyPlayer</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if the player is rendered or not. </p>
<p>Used on the client side to disable the rendering of all <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> objects. This is mainly for the tools or debugging. </p>

</div>
</div>
</div>

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
