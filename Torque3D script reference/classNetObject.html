<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Torque 3D - Script Manual: NetObject Class Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" href="https://github.com/LuisAntonRebollo/Torque-3D-Wiki-Test/wiki">Wiki</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER -->
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>NetObject Class Reference<br/>
<small>
[<a class="el" href="group__Networking.html">Networking</a>]</small>
</h1><!-- doxytag: class="NetObject" --><!-- doxytag: inherits="SimObject" -->
<p>Superclass for all ghostable networked objects.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for NetObject:</div>
<div class="dynsection">
<div class="center"><img src="classNetObject__inherit__graph.png" border="0" usemap="#NetObject_inherit__map" alt="Inheritance graph"/></div>
<map name="NetObject_inherit__map" id="NetObject_inherit__map">
<area shape="rect" href="classLevelInfo.html" title="Stores and controls the rendering and status information for a game level." alt="" coords="289,740,359,767"/><area shape="rect" href="classMissionArea.html" title="Level object which defines the boundaries of the level." alt="" coords="277,791,371,817"/><area shape="rect" href="classSceneObject.html" title="A networkable object that exists in the 3D world." alt="" coords="276,841,372,868"/><area shape="rect" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject." alt="" coords="264,892,384,919"/><area shape="rect" href="classSimObject.html" title="Base class for almost all objects involved in the simulation." alt="" coords="5,816,88,843"/><area shape="rect" href="classBasicClouds.html" title="Renders up to three layers of scrolling cloud&#45;cover textures overhead." alt="" coords="468,5,561,32"/><area shape="rect" href="classCloudLayer.html" title="A layer of clouds which change shape over time and are affected by scene lighting..." alt="" coords="472,56,557,83"/><area shape="rect" href="classConvexShape.html" title="A renderable, collidable convex shape defined by a collection of surface planes." alt="" coords="465,107,564,133"/><area shape="rect" href="classDecalManager.html" title="All decals are managed by the decal manager. Provides a few global variables for..." alt="" coords="463,157,567,184"/><area shape="rect" href="classDecalRoad.html" title="A strip shaped decal defined by spine nodes which clips against Terrain objects." alt="" coords="473,208,556,235"/><area shape="rect" href="classForest.html" title="Forest is a global&#45;bounds scene object provides collision and rendering for a (.forest)..." alt="" coords="485,259,544,285"/><area shape="rect" href="classForestWindEmitter.html" title="Object responsible for simulating wind in a level." alt="" coords="449,309,580,336"/><area shape="rect" href="classfxFoliageReplicator.html" title="An emitter to replicate fxFoliageItem objects across an area." alt="" coords="449,360,580,387"/><area shape="rect" href="classfxShapeReplicatedStatic.html" title="The object definition for shapes that will be replicated across an area using an..." alt="" coords="433,411,596,437"/><area shape="rect" href="classfxShapeReplicator.html" title="An emitter for objects to replicate across an area." alt="" coords="452,461,577,488"/><area shape="rect" href="classGameBase.html" title="Base class for game objects which use datablocks, networking, are editable, and need..." alt="" coords="472,512,557,539"/><area shape="rect" href="classGroundCover.html" title="Covers the ground in a field of objects (IE: Grass, Flowers, etc)." alt="" coords="467,563,563,589"/><area shape="rect" href="classGroundPlane.html" title="An infinite plane extending in all direction." alt="" coords="467,613,563,640"/><area shape="rect" href="classInteriorInstance.html" title="Object used to represent buildings and other architectural structures (legacy)." alt="" coords="460,664,569,691"/><area shape="rect" href="classLightBase.html" title="This is the base class for light objects." alt="" coords="475,715,555,741"/><area shape="rect" href="classMarker.html" title="A single joint, or knot, along a path. Should be stored inside a Path container object..." alt="" coords="484,765,545,792"/><area shape="rect" href="classMeshRoad.html" title="A strip of rectangular mesh segments defined by a 3D spline for prototyping road&#45;shaped..." alt="" coords="473,816,556,843"/><area shape="rect" href="classOcclusionVolume.html" title="OcclusionVolume" alt="" coords="453,867,576,893"/><area shape="rect" href="classPhysicalZone.html" title="Physical Zones are areas that modify the player&#39;s gravity and/or velocity and/or..." alt="" coords="465,917,564,944"/><area shape="rect" href="classPhysicsForce.html" title="Helper object for gameplay physical forces. WIP." alt="" coords="464,968,565,995"/><area shape="rect" href="classPrefab.html" title="A collection of arbitrary objects which can be allocated and manipulated as a group..." alt="" coords="485,1019,544,1045"/><area shape="rect" href="classRenderMeshExample.html" title="An example scene object which renders a mesh." alt="" coords="443,1069,587,1096"/><area shape="rect" href="classRenderObjectExample.html" title="An example scene object which renders using a callback." alt="" coords="439,1120,591,1147"/><area shape="rect" href="classRenderShapeExample.html" title="An example scene object which renders a DTS." alt="" coords="440,1171,589,1197"/><area shape="rect" href="classScatterSky.html" title="Represents both the sun and sky for scenes with a dynamic time of day." alt="" coords="472,1221,557,1248"/><area shape="rect" href="classSFXEmitter.html" title="An invisible 3D object that emits sound." alt="" coords="471,1272,559,1299"/><area shape="rect" href="classSFXSpace.html" title="A volume in space that defines an ambient sound zone." alt="" coords="473,1323,556,1349"/><area shape="rect" href="classSkyBox.html" title="Represents the sky with an artist&#45;created cubemap." alt="" coords="481,1373,548,1400"/><area shape="rect" href="classSun.html" title="A global light affecting your entire scene and optionally renders a corona effect..." alt="" coords="493,1424,536,1451"/><area shape="rect" href="classTerrainBlock.html" title="Represent a terrain object in a Torque 3D level." alt="" coords="468,1475,561,1501"/><area shape="rect" href="classTimeOfDay.html" title="Environmental object that triggers a day/night cycle in level." alt="" coords="472,1525,557,1552"/><area shape="rect" href="classTSStatic.html" title="A static object derived from a 3D model file and placed within the game world." alt="" coords="479,1576,551,1603"/><area shape="rect" href="classWaterObject.html" title="Abstract base class for representing a body of water." alt="" coords="468,1627,561,1653"/><area shape="rect" href="classZone.html" title="An object that culls the rendering of everything contained within it." alt="" coords="491,1677,539,1704"/><area shape="rect" href="classDebris.html" title="Base debris class. Uses the DebrisData datablock for properties of individual debris..." alt="" coords="685,309,744,336"/><area shape="rect" href="classExplosion.html" title="The emitter for an explosion, whose properties are defined in an ExplosionData object..." alt="" coords="676,360,753,387"/><area shape="rect" href="classLightning.html" title="An individual lightning bolt, created from a LightningData object." alt="" coords="679,411,751,437"/><area shape="rect" href="classParticleEmitter.html" title="This object is responsible for all particle emissions." alt="" coords="661,461,768,488"/><area shape="rect" href="classParticleEmitterNode.html" title="Manages timing update information for the assigned particleEmitter. Particles can..." alt="" coords="647,512,783,539"/><area shape="rect" href="classPhysicsDebris.html" title="Represents one or more rigid bodies defined in a single mesh file with a limited..." alt="" coords="663,563,767,589"/><area shape="rect" href="classPhysicsShape.html" title="Represents a destructible physical object simulated through the plugin system." alt="" coords="663,613,767,640"/><area shape="rect" href="classPrecipitation.html" title="Defines a precipitation based storm (IE: rain, snow, etc.)." alt="" coords="668,664,761,691"/><area shape="rect" href="classProjectile.html" title="Base projectile class. Uses the ProjectileData class for properties of individual..." alt="" coords="677,715,752,741"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classNetObject-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#ab872f078257d624bcce131d05c86634e">clearScopeToClient</a> (<a class="el" href="classNetConnection.html">NetConnection</a> client)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Undo the effects of a <a class="el" href="classNetObject.html#aae09e89a353c3a37e145f88e3805fb1e" title="Cause the NetObject to be forced as scoped on the specified NetConnection.">scopeToClient()</a> call.  <a href="#ab872f078257d624bcce131d05c86634e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#afcd60167b0b2224466509bf10d41bdac">getClientObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the client object when on a local connection.  <a href="#afcd60167b0b2224466509bf10d41bdac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#a080837c4169d8368c270f77430ac7971">getGhostID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the ghost index of this object from the server.  <a href="#a080837c4169d8368c270f77430ac7971"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#a7f81d15a49f856fcbb706c476eea0c6e">getServerObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the client object when on a local connection.  <a href="#a7f81d15a49f856fcbb706c476eea0c6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#a57961cf222985cc181d6670b45a82d26">isClientObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to check if an object resides on the clientside.  <a href="#a57961cf222985cc181d6670b45a82d26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#a69dbc5b82f78d44955632f7bf85c28e0">isServerObject</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if an object resides on the server.  <a href="#a69dbc5b82f78d44955632f7bf85c28e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#aae09e89a353c3a37e145f88e3805fb1e">scopeToClient</a> (<a class="el" href="classNetConnection.html">NetConnection</a> client)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause the <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a> to be forced as scoped on the specified <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a>.  <a href="#aae09e89a353c3a37e145f88e3805fb1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetObject.html#a4798b1b113ed53155741c724a164e125">setScopeAlways</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always scope this object on all connections.  <a href="#a4798b1b113ed53155741c724a164e125"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Superclass for all ghostable networked objects. </p>
<h2><a class="anchor" id="NetObject_intro">
Introduction To NetObject And Ghosting</a></h2>
<p>This class is the basis of the ghost implementation in Torque 3D. Every 3D object is a <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a>. One of the most powerful aspects of Torque's networking code is its support for ghosting and prioritized, most-recent-state network updates. The way this works is a bit complex, but it is immensely efficient. Let's run through the steps that the server goes through for each client in this part of Torque's networking:</p>
<ul>
<li>First, the server determines what objects are in-scope for the client. This is done by calling onCameraScopeQuery() on the object which is considered the "scope" object. This is usually the player object, but it can be something else. (For instance, the current vehicle, or a object we're remote controlling.)</li>
</ul>
<ul>
<li>Second, it ghosts them to the client; this is implemented in netGhost.cc.</li>
</ul>
<ul>
<li>Finally, it sends updates as needed, by checking the dirty list and packing updates.</li>
</ul>
<p>There several significant advantages to using this networking system:</p>
<ul>
<li>Efficient network usage, since we only send data that has changed. In addition, since we only care about most-recent data, if a packet is dropped, we don't waste effort trying to deliver stale data.</li>
<li>Cheating protection; since we don't deliver information about game objects which aren't in scope, we dramatically reduce the ability of clients to hack the game and gain a meaningful advantage. (For instance, they can't find out about things behind them, since objects behind them don't fall in scope.) In addition, since ghost IDs are assigned per-client, it's difficult for any sort of co-ordination between cheaters to occur.</li>
</ul>
<p><a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> contains the Ghost Manager implementation, which deals with transferring data to the appropriate clients and keeping state in synch.</p>
<h2><a class="anchor" id="NetObject_Implementation">
An Example Implementation</a></h2>
<p>The basis of the ghost implementation in Torque is <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a>. It tracks the dirty flags for the various states that the object trackers, and does some other book-keeping to allow more efficient operation of the networking layer.</p>
<p>Using a <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a> is very simple; let's go through a simple example implementation:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span><a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a> : <span class="keyword">public</span> <a class="code" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a>
   {
   <span class="keyword">public</span>:
     <span class="keyword">typedef</span> <a class="code" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a> Parent;
     DECLARE_CONOBJECT(<a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a>);
</pre></div><p>Above is the standard boilerplate code for a Torque class. You can find out more about this in <a class="el" href="classSimObject.html" title="Base class for almost all objects involved in the simulation.">SimObject</a>.</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> message1[256];
      <span class="keywordtype">char</span> message2[256];
      <span class="keyword">enum</span> States {
         Message1Mask = BIT(0),
         Message2Mask = BIT(1),
      };
</pre></div><p>For our example, we're having two "states" that we keep track of, message1 and message2. In a real object, we might map our states to health and position, or some other set of fields. You have 32 bits to work with, so it's possible to be very specific when defining states. In general, you should try to use as few states as possible (you never know when you'll need to expand your object's functionality!), and in fact, most of your fields will end up changing all at once, so it's not worth it to be too fine-grained. (As an example, position and velocity on <a class="el" href="classPlayer.html" title="A client-controlled player character.">Player</a> are controlled by the same bit, as one rarely changes without the other changing, too.)</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a>()
      {
         <span class="comment">// in order for an object to be considered by the network system,</span>
         <span class="comment">// the Ghostable net flag must be set.</span>
         <span class="comment">// the ScopeAlways flag indicates that the object is always scoped</span>
         <span class="comment">// on all active connections.</span>
         mNetFlags.set(ScopeAlways | Ghostable);
         dStrcpy(message1, <span class="stringliteral">&quot;Hello World 1!&quot;</span>);
         dStrcpy(message2, <span class="stringliteral">&quot;Hello World 2!&quot;</span>);
      }
</pre></div><p>Here is the constructor. Here, you see that we initialize our net flags to show that we should always be scoped, and that we're to be taken into consideration for ghosting. We also provide some initial values for the message fields.</p>
<div class="fragment"><pre class="fragment">      U32 packUpdate(<a class="code" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> *, U32 mask, BitStream *stream)
      {
         <span class="comment">// check which states need to be updated, and update them</span>
         <span class="keywordflow">if</span>(stream-&gt;writeFlag(mask &amp; Message1Mask))
            stream-&gt;writeString(message1);
         <span class="keywordflow">if</span>(stream-&gt;writeFlag(mask &amp; Message2Mask))
            stream-&gt;writeString(message2);


         <span class="comment">// the return value from packUpdate can set which states still</span>
         <span class="comment">// need to be updated for this object.</span>
         <span class="keywordflow">return</span> 0;
      }
</pre></div><p>Here's half of the meat of the networking code, the packUpdate() function. (The other half, unpackUpdate(), we'll get to in a second.) The comments in the code pretty much explain everything, however, notice that the code follows a pattern of if(writeFlag(mask &amp; StateMask)) { ... write data ... }. The packUpdate()/unpackUpdate() functions are responsible for reading and writing the dirty bits to the bitstream by themselves.</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> unpackUpdate(<a class="code" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> *, BitStream *stream)
      {
         <span class="comment">// the unpackUpdate function must be symmetrical to packUpdate</span>
         <span class="keywordflow">if</span>(stream-&gt;readFlag())
         {
            stream-&gt;readString(message1);
            Con::printf(<span class="stringliteral">&quot;Got message1: %s&quot;</span>, message1);
         }
         <span class="keywordflow">if</span>(stream-&gt;readFlag())
         {
            stream-&gt;readString(message2);
            Con::printf(<span class="stringliteral">&quot;Got message2: %s&quot;</span>, message2);
         }
      }
</pre></div><p>The other half of the networking code in any <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a>, unpackUpdate(). In our simple example, all that the code does is print the new messages to the console; however, in a more advanced object, you might trigger animations, update complex object properties, or even spawn new objects, based on what packet data you unpack.</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> setMessage1(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
      {
         setMaskBits(Message1Mask);
         dStrcpy(message1, msg);
      }
      <span class="keywordtype">void</span> setMessage2(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
      {
         setMaskBits(Message2Mask);
         dStrcpy(message2, msg);
      }
</pre></div><p>Here are the accessors for the two properties. It is good to encapsulate your state variables, so that you don't have to remember to make a call to setMaskBits every time you change anything; the accessors can do it for you. In a more complex object, you might need to set multiple mask bits when you change something; this can be done using the | operator, for instance, setMaskBits( Message1Mask | Message2Mask ); if you changed both messages.</p>
<div class="fragment"><pre class="fragment">   IMPLEMENT_CO_NETOBJECT_V1(<a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a>);


   ConsoleMethod(<a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a>, setMessage1, <span class="keywordtype">void</span>, 3, 3, <span class="stringliteral">&quot;(string msg) Set message 1.&quot;</span>)
   {
      <span class="keywordtype">object</span>-&gt;setMessage1(argv[2]);
   }


   ConsoleMethod(<a class="code" href="classSimpleNetObject.html" title="A very simple example of a class derived from NetObject.">SimpleNetObject</a>, setMessage2, <span class="keywordtype">void</span>, 3, 3, <span class="stringliteral">&quot;(string msg) Set message 2.&quot;</span>)
   {
      <span class="keywordtype">object</span>-&gt;setMessage2(argv[2]);
   }
</pre></div><p>Finally, we use the <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a> implementation macro, IMPLEMENT_CO_NETOBJECT_V1(), to implement our <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a>. It is important that we use this, as it makes Torque perform certain initialization tasks that allow us to send the object over the network. IMPLEMENT_CONOBJECT() doesn't perform these tasks, see the documentation on AbstractClassRep for more details.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a> </dd>
<dd>
<a class="el" href="classSceneObject.html" title="A networkable object that exists in the 3D world.">SceneObject</a> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab872f078257d624bcce131d05c86634e"></a><!-- doxytag: member="NetObject::clearScopeToClient" ref="ab872f078257d624bcce131d05c86634e" args="(NetConnection client)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetObject::clearScopeToClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNetConnection.html">NetConnection</a>&nbsp;</td>
          <td class="paramname"> <em>client</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undo the effects of a <a class="el" href="classNetObject.html#aae09e89a353c3a37e145f88e3805fb1e" title="Cause the NetObject to be forced as scoped on the specified NetConnection.">scopeToClient()</a> call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>client</em>&nbsp;</td><td>The connection to remove this object's scoping from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcd60167b0b2224466509bf10d41bdac"></a><!-- doxytag: member="NetObject::getClientObject" ref="afcd60167b0b2224466509bf10d41bdac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetObject::getClientObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the client object when on a local connection. </p>
<p>Short-Circuit-Networking: this is only valid for a local-client / singleplayer situation.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"><span class="comment">// Psuedo-code, some values left out for this example</span>
%node = <span class="keyword">new</span> <a class="code" href="classParticleEmitterNode.html" title="Manages timing update information for the assigned particleEmitter. Particles can...">ParticleEmitterNode</a>(){};
%clientObject = %node.getClientObject();
<span class="keywordflow">if</span>(isObject(%clientObject)
   %clientObject.setTransform(<span class="stringliteral">&quot;0 0 0&quot;</span>);
</pre></div></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ID of client object </dd></dl>

</div>
</div>
<a class="anchor" id="a080837c4169d8368c270f77430ac7971"></a><!-- doxytag: member="NetObject::getGhostID" ref="a080837c4169d8368c270f77430ac7971" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetObject::getGhostID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the ghost index of this object from the server. </p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">%ghostID = LocalClientConnection.getGhostId( %serverObject );
</pre></div></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of this ghost in the GhostManager on the server </dd></dl>

</div>
</div>
<a class="anchor" id="a7f81d15a49f856fcbb706c476eea0c6e"></a><!-- doxytag: member="NetObject::getServerObject" ref="a7f81d15a49f856fcbb706c476eea0c6e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NetObject::getServerObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the client object when on a local connection. </p>
<p>Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"><span class="comment">// Psuedo-code, some values left out for this example</span>
%node = <span class="keyword">new</span> <a class="code" href="classParticleEmitterNode.html" title="Manages timing update information for the assigned particleEmitter. Particles can...">ParticleEmitterNode</a>(){};
%serverObject = %node.getServerObject();
<span class="keywordflow">if</span>(isObject(%serverObject)
   %serverObject.setTransform(<span class="stringliteral">&quot;0 0 0&quot;</span>);
</pre></div></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ID of server object </dd></dl>

</div>
</div>
<a class="anchor" id="a57961cf222985cc181d6670b45a82d26"></a><!-- doxytag: member="NetObject::isClientObject" ref="a57961cf222985cc181d6670b45a82d26" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetObject::isClientObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called to check if an object resides on the clientside. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the object resides on the client, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a69dbc5b82f78d44955632f7bf85c28e0"></a><!-- doxytag: member="NetObject::isServerObject" ref="a69dbc5b82f78d44955632f7bf85c28e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetObject::isServerObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if an object resides on the server. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the object resides on the server, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aae09e89a353c3a37e145f88e3805fb1e"></a><!-- doxytag: member="NetObject::scopeToClient" ref="aae09e89a353c3a37e145f88e3805fb1e" args="(NetConnection client)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetObject::scopeToClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNetConnection.html">NetConnection</a>&nbsp;</td>
          <td class="paramname"> <em>client</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause the <a class="el" href="classNetObject.html" title="Superclass for all ghostable networked objects.">NetObject</a> to be forced as scoped on the specified <a class="el" href="classNetConnection.html" title="Provides the basis for implementing a multiplayer game protocol.">NetConnection</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>client</em>&nbsp;</td><td>The connection this object will always be scoped to</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"><span class="comment">// Called to create new cameras in TorqueScript</span>
<span class="comment">// %this - The active GameConnection</span>
<span class="comment">// %spawnPoint - The spawn point location where we creat the camera</span>
function GameConnection::spawnCamera(%<span class="keyword">this</span>, %spawnPoint)
{
   <span class="comment">// If this connection&#39;s camera exists</span>
   <span class="keywordflow">if</span>(isObject(%this.camera))
   {
      <span class="comment">// Add it to the mission group to be cleaned up later</span>
      MissionCleanup.add( %this.camera );

      <span class="comment">// Force it to scope to the client side</span>
      %this.camera.scopeToClient(%<span class="keyword">this</span>);
   }
}
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a4798b1b113ed53155741c724a164e125"></a><!-- doxytag: member="NetObject::setScopeAlways" ref="a4798b1b113ed53155741c724a164e125" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetObject::setScopeAlways </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Always scope this object on all connections. </p>
<p>The object is marked as ScopeAlways and is immediately ghosted to all active connections. This function has no effect if the object is not marked as Ghostable. </p>

</div>
</div>
</div>

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
